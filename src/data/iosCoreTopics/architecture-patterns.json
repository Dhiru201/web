{
  "id": "architecture-patterns",
  "title": "Architecture Patterns in iOS",
  "sections": [
    {
      "title": "Introduction",
      "content": "Architecture patterns in iOS help organize code, improve maintainability, and facilitate testing. This guide covers common patterns like MVC, MVVM, VIPER, and Clean Architecture, along with their implementation and best practices."
    },
    {
      "title": "MVC (Model-View-Controller)",
      "content": "The traditional Apple-recommended pattern:\n\n```swift\n// Model\nstruct User {\n    let id: Int\n    let name: String\n    let email: String\n}\n\n// View\nclass UserView: UIView {\n    private let nameLabel = UILabel()\n    private let emailLabel = UILabel()\n    \n    func configure(with user: User) {\n        nameLabel.text = user.name\n        emailLabel.text = user.email\n    }\n}\n\n// Controller\nclass UserViewController: UIViewController {\n    private let userView = UserView()\n    private var user: User?\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupView()\n        fetchUser()\n    }\n    \n    private func fetchUser() {\n        // Network call or data fetch\n        user = User(id: 1, name: \"John\", email: \"john@example.com\")\n        userView.configure(with: user!)\n    }\n}\n```"
    },
    {
      "title": "MVVM (Model-View-ViewModel)",
      "content": "A more modern pattern that separates business logic from UI:\n\n```swift\n// Model\nstruct User {\n    let id: Int\n    let name: String\n    let email: String\n}\n\n// ViewModel\nclass UserViewModel {\n    private let user: User\n    \n    var nameText: String { user.name }\n    var emailText: String { user.email }\n    \n    init(user: User) {\n        self.user = user\n    }\n    \n    func fetchUserDetails(completion: @escaping (Result<User, Error>) -> Void) {\n        // Network call or data fetch\n        completion(.success(user))\n    }\n}\n\n// View\nclass UserView: UIView {\n    private let nameLabel = UILabel()\n    private let emailLabel = UILabel()\n    \n    func configure(with viewModel: UserViewModel) {\n        nameLabel.text = viewModel.nameText\n        emailLabel.text = viewModel.emailText\n    }\n}\n\n// ViewController\nclass UserViewController: UIViewController {\n    private let userView = UserView()\n    private var viewModel: UserViewModel?\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupView()\n        setupViewModel()\n    }\n    \n    private func setupViewModel() {\n        let user = User(id: 1, name: \"John\", email: \"john@example.com\")\n        viewModel = UserViewModel(user: user)\n        userView.configure(with: viewModel!)\n    }\n}\n```"
    },
    {
      "title": "VIPER",
      "content": "A clean architecture pattern that separates concerns into distinct layers:\n\n```swift\n// Entity\nstruct User {\n    let id: Int\n    let name: String\n    let email: String\n}\n\n// Router\nprotocol UserRouterProtocol {\n    func navigateToUserDetails(user: User)\n}\n\nclass UserRouter: UserRouterProtocol {\n    weak var viewController: UIViewController?\n    \n    func navigateToUserDetails(user: User) {\n        // Navigation logic\n    }\n}\n\n// Interactor\nprotocol UserInteractorProtocol {\n    func fetchUser(completion: @escaping (Result<User, Error>) -> Void)\n}\n\nclass UserInteractor: UserInteractorProtocol {\n    func fetchUser(completion: @escaping (Result<User, Error>) -> Void) {\n        // Business logic and data fetching\n        let user = User(id: 1, name: \"John\", email: \"john@example.com\")\n        completion(.success(user))\n    }\n}\n\n// Presenter\nprotocol UserPresenterProtocol {\n    func viewDidLoad()\n    func didSelectUser()\n}\n\nclass UserPresenter: UserPresenterProtocol {\n    weak var view: UserViewProtocol?\n    var interactor: UserInteractorProtocol\n    var router: UserRouterProtocol\n    \n    init(interactor: UserInteractorProtocol, router: UserRouterProtocol) {\n        self.interactor = interactor\n        self.router = router\n    }\n    \n    func viewDidLoad() {\n        interactor.fetchUser { [weak self] result in\n            switch result {\n            case .success(let user):\n                self?.view?.displayUser(user)\n            case .failure(let error):\n                self?.view?.displayError(error)\n            }\n        }\n    }\n    \n    func didSelectUser() {\n        // Handle user selection\n    }\n}\n\n// View\nprotocol UserViewProtocol: AnyObject {\n    func displayUser(_ user: User)\n    func displayError(_ error: Error)\n}\n\nclass UserViewController: UIViewController, UserViewProtocol {\n    var presenter: UserPresenterProtocol?\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        presenter?.viewDidLoad()\n    }\n    \n    func displayUser(_ user: User) {\n        // Update UI with user data\n    }\n    \n    func displayError(_ error: Error) {\n        // Show error message\n    }\n}\n```"
    },
    {
      "title": "Clean Architecture",
      "content": "A layered architecture that emphasizes separation of concerns:\n\n```swift\n// Domain Layer\nprotocol UserRepositoryProtocol {\n    func fetchUser(completion: @escaping (Result<User, Error>) -> Void)\n}\n\nstruct User {\n    let id: Int\n    let name: String\n    let email: String\n}\n\n// Data Layer\nclass UserRepository: UserRepositoryProtocol {\n    private let networkService: NetworkServiceProtocol\n    private let cache: CacheProtocol\n    \n    init(networkService: NetworkServiceProtocol, cache: CacheProtocol) {\n        self.networkService = networkService\n        self.cache = cache\n    }\n    \n    func fetchUser(completion: @escaping (Result<User, Error>) -> Void) {\n        // Implementation\n    }\n}\n\n// Presentation Layer\nclass UserViewModel {\n    private let repository: UserRepositoryProtocol\n    \n    var user: Observable<User?> = Observable(nil)\n    var error: Observable<Error?> = Observable(nil)\n    \n    init(repository: UserRepositoryProtocol) {\n        self.repository = repository\n    }\n    \n    func fetchUser() {\n        repository.fetchUser { [weak self] result in\n            switch result {\n            case .success(let user):\n                self?.user.value = user\n            case .failure(let error):\n                self?.error.value = error\n            }\n        }\n    }\n}\n\n// UI Layer\nclass UserViewController: UIViewController {\n    private let viewModel: UserViewModel\n    \n    init(viewModel: UserViewModel) {\n        self.viewModel = viewModel\n        super.init(nibName: nil, bundle: nil)\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupBindings()\n        viewModel.fetchUser()\n    }\n    \n    private func setupBindings() {\n        viewModel.user.bind { [weak self] user in\n            // Update UI with user data\n        }\n        \n        viewModel.error.bind { [weak self] error in\n            // Show error message\n        }\n    }\n}\n```"
    },
    {
      "title": "Best Practices",
      "content": "Follow these best practices when implementing architecture patterns:\n\n1. Keep components loosely coupled\n2. Use dependency injection\n3. Follow SOLID principles\n4. Implement proper error handling\n5. Write unit tests\n6. Document architecture decisions\n\nExample of dependency injection:\n\n```swift\nprotocol ServiceProtocol {\n    func fetchData(completion: @escaping (Result<Data, Error>) -> Void)\n}\n\nclass ViewModel {\n    private let service: ServiceProtocol\n    \n    init(service: ServiceProtocol) {\n        self.service = service\n    }\n    \n    func loadData() {\n        service.fetchData { result in\n            // Handle result\n        }\n    }\n}\n\n// Usage\nlet service = NetworkService()\nlet viewModel = ViewModel(service: service)\n```"
    },
    {
      "title": "Common Use Cases",
      "content": "Here are some common architecture pattern scenarios:\n\n1. Feature Module\n```swift\n// Feature Module Structure\nprotocol FeatureModuleProtocol {\n    func makeViewController() -> UIViewController\n}\n\nclass FeatureModule: FeatureModuleProtocol {\n    func makeViewController() -> UIViewController {\n        let repository = FeatureRepository()\n        let viewModel = FeatureViewModel(repository: repository)\n        return FeatureViewController(viewModel: viewModel)\n    }\n}\n```\n\n2. Coordinator Pattern\n```swift\nprotocol Coordinator: AnyObject {\n    var childCoordinators: [Coordinator] { get set }\n    var navigationController: UINavigationController { get set }\n    func start()\n}\n\nclass AppCoordinator: Coordinator {\n    var childCoordinators: [Coordinator] = []\n    var navigationController: UINavigationController\n    \n    init(navigationController: UINavigationController) {\n        self.navigationController = navigationController\n    }\n    \n    func start() {\n        let viewController = HomeViewController()\n        viewController.coordinator = self\n        navigationController.pushViewController(viewController, animated: false)\n    }\n    \n    func showDetail(for item: Item) {\n        let coordinator = DetailCoordinator(navigationController: navigationController, item: item)\n        childCoordinators.append(coordinator)\n        coordinator.start()\n    }\n}\n```\n\n3. Repository Pattern\n```swift\nprotocol RepositoryProtocol {\n    associatedtype T\n    func fetch(completion: @escaping (Result<[T], Error>) -> Void)\n    func save(_ items: [T], completion: @escaping (Result<Void, Error>) -> Void)\n}\n\nclass Repository<T>: RepositoryProtocol {\n    private let remoteDataSource: RemoteDataSourceProtocol\n    private let localDataSource: LocalDataSourceProtocol\n    \n    init(remoteDataSource: RemoteDataSourceProtocol, localDataSource: LocalDataSourceProtocol) {\n        self.remoteDataSource = remoteDataSource\n        self.localDataSource = localDataSource\n    }\n    \n    func fetch(completion: @escaping (Result<[T], Error>) -> Void) {\n        // Implementation\n    }\n    \n    func save(_ items: [T], completion: @escaping (Result<Void, Error>) -> Void) {\n        // Implementation\n    }\n}\n```"
    }
  ]
} 