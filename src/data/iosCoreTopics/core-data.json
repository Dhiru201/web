{
  "id": "core-data",
  "title": "Core Data in iOS",
  "sections": [
    {
      "title": "Introduction",
      "content": "Core Data is Apple's framework for managing the model layer objects in your application. It provides generalized and automated solutions to common tasks associated with object life cycle and object graph management, including persistence. This guide covers Core Data fundamentals and advanced concepts."
    },
    {
      "title": "Core Data Stack",
      "content": "Setting up the Core Data stack:\n\n```swift\nimport CoreData\n\nclass CoreDataManager {\n    static let shared = CoreDataManager()\n    \n    private init() {}\n    \n    // MARK: - Core Data stack\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"YourAppName\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n    \n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n    \n    // MARK: - Core Data Saving support\n    func saveContext() {\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}\n```"
    },
    {
      "title": "Data Model",
      "content": "Creating and using the data model:\n\n```swift\n// MARK: - Entity Definitions\n@objc(User)\npublic class User: NSManagedObject {\n    @NSManaged public var id: UUID\n    @NSManaged public var name: String\n    @NSManaged public var email: String\n    @NSManaged public var posts: NSSet?\n}\n\n@objc(Post)\npublic class Post: NSManagedObject {\n    @NSManaged public var id: UUID\n    @NSManaged public var title: String\n    @NSManaged public var content: String\n    @NSManaged public var createdAt: Date\n    @NSManaged public var user: User?\n}\n\n// MARK: - Generated accessors for User\nextension User {\n    @objc(addPostsObject:)\n    @NSManaged public func addToPosts(_ value: Post)\n    \n    @objc(removePostsObject:)\n    @NSManaged public func removeFromPosts(_ value: Post)\n    \n    @objc(addPosts:)\n    @NSManaged public func addToPosts(_ values: NSSet)\n    \n    @objc(removePosts:)\n    @NSManaged public func removeFromPosts(_ values: NSSet)\n}\n```"
    },
    {
      "title": "CRUD Operations",
      "content": "Performing CRUD operations with Core Data:\n\n```swift\nclass DataManager {\n    // Create\n    func createUser(name: String, email: String) -> User {\n        let user = User(context: CoreDataManager.shared.context)\n        user.id = UUID()\n        user.name = name\n        user.email = email\n        CoreDataManager.shared.saveContext()\n        return user\n    }\n    \n    // Read\n    func fetchUsers() -> [User] {\n        let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n        do {\n            return try CoreDataManager.shared.context.fetch(fetchRequest)\n        } catch {\n            print(\"Error fetching users: \\(error)\")\n            return []\n        }\n    }\n    \n    // Update\n    func updateUser(_ user: User, name: String? = nil, email: String? = nil) {\n        if let name = name { user.name = name }\n        if let email = email { user.email = email }\n        CoreDataManager.shared.saveContext()\n    }\n    \n    // Delete\n    func deleteUser(_ user: User) {\n        CoreDataManager.shared.context.delete(user)\n        CoreDataManager.shared.saveContext()\n    }\n}\n```"
    },
    {
      "title": "Fetch Requests",
      "content": "Using fetch requests with predicates and sorting:\n\n```swift\nclass DataManager {\n    // Basic fetch request\n    func fetchUsers() -> [User] {\n        let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n        return try! CoreDataManager.shared.context.fetch(fetchRequest)\n    }\n    \n    // Fetch with predicate\n    func fetchUsersWithName(_ name: String) -> [User] {\n        let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n        fetchRequest.predicate = NSPredicate(format: \"name CONTAINS[c] %@\", name)\n        return try! CoreDataManager.shared.context.fetch(fetchRequest)\n    }\n    \n    // Fetch with sorting\n    func fetchUsersSortedByName() -> [User] {\n        let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n        let sortDescriptor = NSSortDescriptor(key: \"name\", ascending: true)\n        fetchRequest.sortDescriptors = [sortDescriptor]\n        return try! CoreDataManager.shared.context.fetch(fetchRequest)\n    }\n    \n    // Fetch with relationship\n    func fetchPostsForUser(_ user: User) -> [Post] {\n        let fetchRequest: NSFetchRequest<Post> = Post.fetchRequest()\n        fetchRequest.predicate = NSPredicate(format: \"user == %@\", user)\n        return try! CoreDataManager.shared.context.fetch(fetchRequest)\n    }\n}\n```"
    },
    {
      "title": "Batch Operations",
      "content": "Performing batch operations for better performance:\n\n```swift\nclass DataManager {\n    // Batch insert\n    func batchInsertUsers(_ users: [(name: String, email: String)]) {\n        let batchInsert = NSBatchInsertRequest(entity: User.entity()) { (managedObject: NSManagedObject) in\n            let user = managedObject as! User\n            let data = users[Int(managedObject.hash) % users.count]\n            user.id = UUID()\n            user.name = data.name\n            user.email = data.email\n        }\n        \n        batchInsert.resultType = .objectIDs\n        \n        do {\n            let result = try CoreDataManager.shared.context.execute(batchInsert) as! NSBatchInsertResult\n            let changes: [AnyHashable: Any] = [NSInsertedObjectsKey: result.result as! [NSManagedObjectID]]\n            NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [CoreDataManager.shared.context])\n        } catch {\n            print(\"Error batch inserting: \\(error)\")\n        }\n    }\n    \n    // Batch update\n    func batchUpdateUserNames() {\n        let batchUpdate = NSBatchUpdateRequest(entity: User.entity())\n        batchUpdate.propertiesToUpdate = [\"name\": \"Updated Name\"]\n        batchUpdate.resultType = .updatedObjectsCountResultType\n        \n        do {\n            let result = try CoreDataManager.shared.context.execute(batchUpdate) as! NSBatchUpdateResult\n            print(\"Updated \\(result.result!) objects\")\n        } catch {\n            print(\"Error batch updating: \\(error)\")\n        }\n    }\n    \n    // Batch delete\n    func batchDeleteUsers() {\n        let fetchRequest: NSFetchRequest<NSFetchRequestResult> = User.fetchRequest()\n        let batchDelete = NSBatchDeleteRequest(fetchRequest: fetchRequest)\n        batchDelete.resultType = .resultTypeObjectIDs\n        \n        do {\n            let result = try CoreDataManager.shared.context.execute(batchDelete) as! NSBatchDeleteResult\n            let changes: [AnyHashable: Any] = [NSDeletedObjectsKey: result.result as! [NSManagedObjectID]]\n            NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [CoreDataManager.shared.context])\n        } catch {\n            print(\"Error batch deleting: \\(error)\")\n        }\n    }\n}\n```"
    },
    {
      "title": "Best Practices",
      "content": "Follow these best practices when working with Core Data:\n\n1. Use appropriate context types\n2. Implement proper error handling\n3. Use batch operations for large datasets\n4. Implement proper migration strategies\n5. Use background contexts for heavy operations\n6. Monitor memory usage\n\nExample of background context usage:\n\n```swift\nclass DataManager {\n    func performBackgroundTask(_ block: @escaping (NSManagedObjectContext) -> Void) {\n        let backgroundContext = CoreDataManager.shared.persistentContainer.newBackgroundContext()\n        backgroundContext.perform {\n            block(backgroundContext)\n            \n            if backgroundContext.hasChanges {\n                do {\n                    try backgroundContext.save()\n                } catch {\n                    print(\"Error saving background context: \\(error)\")\n                }\n            }\n        }\n    }\n}\n```"
    },
    {
      "title": "Common Use Cases",
      "content": "Here are some common Core Data scenarios:\n\n1. Data Migration\n```swift\nclass DataManager {\n    func setupCoreDataStack() {\n        let container = NSPersistentContainer(name: \"YourAppName\")\n        \n        let description = NSPersistentStoreDescription()\n        description.shouldMigrateStoreAutomatically = true\n        description.shouldInferMappingModelAutomatically = true\n        \n        container.persistentStoreDescriptions = [description]\n        \n        container.loadPersistentStores { (description, error) in\n            if let error = error {\n                print(\"Error setting up Core Data: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n2. NSFetchedResultsController\n```swift\nclass UsersViewController: UIViewController {\n    private var fetchedResultsController: NSFetchedResultsController<User>!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupFetchedResultsController()\n    }\n    \n    private func setupFetchedResultsController() {\n        let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n        let sortDescriptor = NSSortDescriptor(key: \"name\", ascending: true)\n        fetchRequest.sortDescriptors = [sortDescriptor]\n        \n        fetchedResultsController = NSFetchedResultsController(\n            fetchRequest: fetchRequest,\n            managedObjectContext: CoreDataManager.shared.context,\n            sectionNameKeyPath: nil,\n            cacheName: nil\n        )\n        \n        fetchedResultsController.delegate = self\n        \n        do {\n            try fetchedResultsController.performFetch()\n        } catch {\n            print(\"Error performing fetch: \\(error)\")\n        }\n    }\n}\n\nextension UsersViewController: NSFetchedResultsControllerDelegate {\n    func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {\n        // Update UI\n    }\n}\n```\n\n3. Core Data with CloudKit\n```swift\nclass DataManager {\n    func setupCloudKitSync() {\n        let container = NSPersistentCloudKitContainer(name: \"YourAppName\")\n        \n        container.loadPersistentStores { (description, error) in\n            if let error = error {\n                print(\"Error setting up CloudKit sync: \\(error)\")\n            }\n        }\n        \n        // Enable remote notifications\n        container.viewContext.automaticallyMergesChangesFromParent = true\n        \n        // Observe remote changes\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(handleRemoteStoreChange),\n            name: .NSPersistentStoreRemoteChange,\n            object: container.persistentStoreCoordinator\n        )\n    }\n    \n    @objc private func handleRemoteStoreChange(_ notification: Notification) {\n        // Handle remote changes\n    }\n}\n```"
    }
  ]
} 