{
  "id": "networking",
  "title": "Networking in iOS",
  "sections": [
    {
      "title": "Introduction",
      "content": "Networking in iOS involves making HTTP requests to web services and handling responses. iOS provides several ways to handle networking, including URLSession, Alamofire, and custom networking layers. This guide covers these methods and best practices."
    },
    {
      "title": "URLSession Basics",
      "content": "URLSession is Apple's native networking framework:\n\n```swift\n// Basic GET request\nfunc fetchData() {\n    guard let url = URL(string: \"https://api.example.com/data\") else { return }\n    \n    let task = URLSession.shared.dataTask(with: url) { data, response, error in\n        if let error = error {\n            print(\"Error: \\(error.localizedDescription)\")\n            return\n        }\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              (200...299).contains(httpResponse.statusCode) else {\n            print(\"Invalid response\")\n            return\n        }\n        \n        if let data = data,\n           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {\n            print(json)\n        }\n    }\n    \n    task.resume()\n}\n\n// POST request with JSON body\nfunc postData() {\n    guard let url = URL(string: \"https://api.example.com/data\") else { return }\n    \n    var request = URLRequest(url: url)\n    request.httpMethod = \"POST\"\n    request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n    \n    let body: [String: Any] = [\"name\": \"John\", \"age\": 30]\n    request.httpBody = try? JSONSerialization.data(withJSONObject: body)\n    \n    let task = URLSession.shared.dataTask(with: request) { data, response, error in\n        // Handle response\n    }\n    \n    task.resume()\n}\n```"
    },
    {
      "title": "URLSession Configuration",
      "content": "Custom URLSession configurations for different needs:\n\n```swift\n// Default configuration\nlet defaultConfig = URLSessionConfiguration.default\n\n// Ephemeral configuration (no caching)\nlet ephemeralConfig = URLSessionConfiguration.ephemeral\n\n// Background configuration\nlet backgroundConfig = URLSessionConfiguration.background(withIdentifier: \"com.example.background\")\n\n// Custom session with configuration\nlet session = URLSession(configuration: defaultConfig)\n\n// Custom session with delegate\nclass NetworkDelegate: NSObject, URLSessionDelegate, URLSessionTaskDelegate {\n    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {\n        if let error = error {\n            print(\"Task completed with error: \\(error.localizedDescription)\")\n        } else {\n            print(\"Task completed successfully\")\n        }\n    }\n}\n\nlet delegate = NetworkDelegate()\nlet sessionWithDelegate = URLSession(configuration: .default, delegate: delegate, delegateQueue: nil)\n```"
    },
    {
      "title": "Alamofire",
      "content": "Alamofire is a popular networking library that simplifies URLSession:\n\n```swift\nimport Alamofire\n\nclass NetworkManager {\n    static let shared = NetworkManager()\n    \n    func fetchData() {\n        AF.request(\"https://api.example.com/data\")\n            .validate()\n            .responseJSON { response in\n                switch response.result {\n                case .success(let value):\n                    print(value)\n                case .failure(let error):\n                    print(error.localizedDescription)\n                }\n            }\n    }\n    \n    func postData() {\n        let parameters: [String: Any] = [\"name\": \"John\", \"age\": 30]\n        \n        AF.request(\"https://api.example.com/data\",\n                  method: .post,\n                  parameters: parameters,\n                  encoding: JSONEncoding.default)\n            .validate()\n            .responseJSON { response in\n                // Handle response\n            }\n    }\n    \n    func uploadFile() {\n        let fileURL = Bundle.main.url(forResource: \"image\", withExtension: \"jpg\")!\n        \n        AF.upload(fileURL, to: \"https://api.example.com/upload\")\n            .uploadProgress { progress in\n                print(\"Upload Progress: \\(progress.fractionCompleted)\")\n            }\n            .responseJSON { response in\n                // Handle response\n            }\n    }\n}\n```"
    },
    {
      "title": "Networking Layer",
      "content": "Creating a custom networking layer for better organization:\n\n```swift\nenum NetworkError: Error {\n    case invalidURL\n    case noData\n    case decodingError\n    case serverError(String)\n}\n\nprotocol NetworkServiceProtocol {\n    func request<T: Decodable>(endpoint: Endpoint, completion: @escaping (Result<T, NetworkError>) -> Void)\n}\n\nclass NetworkService: NetworkServiceProtocol {\n    private let session: URLSession\n    \n    init(session: URLSession = .shared) {\n        self.session = session\n    }\n    \n    func request<T: Decodable>(endpoint: Endpoint, completion: @escaping (Result<T, NetworkError>) -> Void) {\n        guard let url = endpoint.url else {\n            completion(.failure(.invalidURL))\n            return\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = endpoint.method.rawValue\n        request.allHTTPHeaderFields = endpoint.headers\n        \n        if let parameters = endpoint.parameters {\n            request.httpBody = try? JSONSerialization.data(withJSONObject: parameters)\n        }\n        \n        let task = session.dataTask(with: request) { data, response, error in\n            if let error = error {\n                completion(.failure(.serverError(error.localizedDescription)))\n                return\n            }\n            \n            guard let data = data else {\n                completion(.failure(.noData))\n                return\n            }\n            \n            do {\n                let decoded = try JSONDecoder().decode(T.self, from: data)\n                completion(.success(decoded))\n            } catch {\n                completion(.failure(.decodingError))\n            }\n        }\n        \n        task.resume()\n    }\n}\n\n// Usage\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nlet networkService = NetworkService()\nnetworkService.request(endpoint: UserEndpoint.getUser(id: 1)) { (result: Result<User, NetworkError>) in\n    switch result {\n    case .success(let user):\n        print(user.name)\n    case .failure(let error):\n        print(error)\n    }\n}\n```"
    },
    {
      "title": "Best Practices",
      "content": "Follow these best practices for networking in iOS:\n\n1. Use proper error handling\n2. Implement request timeouts\n3. Handle different response types\n4. Use background sessions for large downloads\n5. Implement proper caching strategies\n6. Consider network reachability\n\nExample of network reachability:\n\n```swift\nimport Network\n\nclass NetworkMonitor {\n    static let shared = NetworkMonitor()\n    private let monitor = NWPathMonitor()\n    private let queue = DispatchQueue(label: \"NetworkMonitor\")\n    \n    var isConnected: Bool = false\n    var connectionType: NWInterface.InterfaceType?\n    \n    private init() {\n        monitor.pathUpdateHandler = { [weak self] path in\n            self?.isConnected = path.status == .satisfied\n            self?.connectionType = path.availableInterfaces.first?.type\n        }\n        monitor.start(queue: queue)\n    }\n    \n    func stopMonitoring() {\n        monitor.cancel()\n    }\n}\n```"
    },
    {
      "title": "Common Use Cases",
      "content": "Here are some common networking scenarios:\n\n1. Image Loading with Caching\n```swift\nclass ImageLoader {\n    static let shared = ImageLoader()\n    private let cache = NSCache<NSString, UIImage>()\n    \n    func loadImage(from url: URL, completion: @escaping (UIImage?) -> Void) {\n        if let cachedImage = cache.object(forKey: url.absoluteString as NSString) {\n            completion(cachedImage)\n            return\n        }\n        \n        URLSession.shared.dataTask(with: url) { [weak self] data, response, error in\n            guard let data = data, let image = UIImage(data: data) else {\n                completion(nil)\n                return\n            }\n            \n            self?.cache.setObject(image, forKey: url.absoluteString as NSString)\n            completion(image)\n        }.resume()\n    }\n}\n```\n\n2. API Client\n```swift\nclass APIClient {\n    static let shared = APIClient()\n    private let baseURL = \"https://api.example.com\"\n    \n    func fetchUsers(completion: @escaping (Result<[User], Error>) -> Void) {\n        guard let url = URL(string: \"\\(baseURL)/users\") else { return }\n        \n        URLSession.shared.dataTask(with: url) { data, response, error in\n            if let error = error {\n                completion(.failure(error))\n                return\n            }\n            \n            guard let data = data else { return }\n            \n            do {\n                let users = try JSONDecoder().decode([User].self, from: data)\n                completion(.success(users))\n            } catch {\n                completion(.failure(error))\n            }\n        }.resume()\n    }\n}\n```\n\n3. File Download with Progress\n```swift\nclass FileDownloader {\n    static let shared = FileDownloader()\n    \n    func downloadFile(from url: URL, progress: @escaping (Double) -> Void, completion: @escaping (URL?) -> Void) {\n        let task = URLSession.shared.downloadTask(with: url) { localURL, response, error in\n            if let error = error {\n                print(\"Download error: \\(error.localizedDescription)\")\n                completion(nil)\n                return\n            }\n            \n            guard let localURL = localURL else {\n                completion(nil)\n                return\n            }\n            \n            completion(localURL)\n        }\n        \n        let observation = task.progress.observe(\\Progress.fractionCompleted) { progress, _ in\n            DispatchQueue.main.async {\n                progress(progress.fractionCompleted)\n            }\n        }\n        \n        task.resume()\n    }\n}\n```"
    }
  ]
} 