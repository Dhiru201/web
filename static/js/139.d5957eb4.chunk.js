"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[139],{139:e=>{e.exports=JSON.parse('{"id":"data-persistence","title":"Data Persistence in iOS","sections":[{"title":"Introduction","content":"Data persistence in iOS refers to the various ways of storing and retrieving data between app launches. iOS provides several options including UserDefaults, File System, Core Data, and SQLite. This guide covers these methods and their appropriate use cases."},{"title":"UserDefaults","content":"UserDefaults is ideal for storing small amounts of data like user preferences and settings:\\n\\n```swift\\n// Storing data\\nlet defaults = UserDefaults.standard\\ndefaults.set(25, forKey: \\"Age\\")\\ndefaults.set(true, forKey: \\"UseFaceID\\")\\ndefaults.set(CGFloat.pi, forKey: \\"Pi\\")\\n\\n// Retrieving data\\nlet age = defaults.integer(forKey: \\"Age\\")\\nlet useFaceID = defaults.bool(forKey: \\"UseFaceID\\")\\nlet pi = defaults.float(forKey: \\"Pi\\")\\n\\n// Storing custom objects\\nstruct User: Codable {\\n    var name: String\\n    var email: String\\n}\\n\\nlet user = User(name: \\"John\\", email: \\"john@example.com\\")\\nif let encoded = try? JSONEncoder().encode(user) {\\n    defaults.set(encoded, forKey: \\"UserData\\")\\n}\\n\\n// Retrieving custom objects\\nif let savedData = defaults.object(forKey: \\"UserData\\") as? Data,\\n   let decodedUser = try? JSONDecoder().decode(User.self, from: savedData) {\\n    print(decodedUser.name)\\n}\\n```"},{"title":"File System","content":"The iOS file system provides directories for different types of data storage:\\n\\n```swift\\n// Get document directory\\nlet documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\\n\\n// Save file\\nlet fileURL = documentsDirectory.appendingPathComponent(\\"example.txt\\")\\ntry? \\"Hello, World!\\".write(to: fileURL, atomically: true, encoding: .utf8)\\n\\n// Read file\\nif let content = try? String(contentsOf: fileURL, encoding: .utf8) {\\n    print(content)\\n}\\n\\n// Save image\\nif let image = UIImage(named: \\"example\\"),\\n   let data = image.jpegData(compressionQuality: 0.8) {\\n    let imageURL = documentsDirectory.appendingPathComponent(\\"image.jpg\\")\\n    try? data.write(to: imageURL)\\n}\\n\\n// Create directory\\nlet newDirectory = documentsDirectory.appendingPathComponent(\\"MyFolder\\")\\ntry? FileManager.default.createDirectory(at: newDirectory, withIntermediateDirectories: true)\\n```"},{"title":"Core Data","content":"Core Data is Apple\'s framework for object graph and persistence management:\\n\\n```swift\\n// Core Data Stack\\nclass CoreDataStack {\\n    static let shared = CoreDataStack()\\n    \\n    lazy var persistentContainer: NSPersistentContainer = {\\n        let container = NSPersistentContainer(name: \\"MyApp\\")\\n        container.loadPersistentStores { description, error in\\n            if let error = error {\\n                fatalError(\\"Unable to load persistent stores: \\\\(error)\\")\\n            }\\n        }\\n        return container\\n    }()\\n    \\n    var context: NSManagedObjectContext {\\n        return persistentContainer.viewContext\\n    }\\n}\\n\\n// Define Entity\\n@objc(Person)\\nclass Person: NSManagedObject {\\n    @NSManaged var name: String\\n    @NSManaged var age: Int16\\n}\\n\\n// Create and Save\\nlet person = Person(context: CoreDataStack.shared.context)\\nperson.name = \\"John\\"\\nperson.age = 30\\n\\ntry? CoreDataStack.shared.context.save()\\n\\n// Fetch\\nlet fetchRequest: NSFetchRequest<Person> = Person.fetchRequest()\\nlet predicate = NSPredicate(format: \\"age > %d\\", 25)\\nfetchRequest.predicate = predicate\\n\\nif let results = try? CoreDataStack.shared.context.fetch(fetchRequest) {\\n    for person in results {\\n        print(person.name)\\n    }\\n}\\n```"},{"title":"SQLite with FMDB","content":"For direct SQLite access, you can use FMDB wrapper:\\n\\n```swift\\nimport FMDB\\n\\nclass DatabaseManager {\\n    static let shared = DatabaseManager()\\n    private let dbQueue: FMDatabaseQueue\\n    \\n    private init() {\\n        let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]\\n        let dbPath = documentsPath.appending(\\"/database.sqlite\\")\\n        dbQueue = FMDatabaseQueue(path: dbPath)!\\n    }\\n    \\n    func createTables() {\\n        dbQueue.inDatabase { db in\\n            try? db.executeUpdate(\\"\\"\\"\\n                CREATE TABLE IF NOT EXISTS Users (\\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\\n                    name TEXT NOT NULL,\\n                    email TEXT UNIQUE NOT NULL\\n                )\\n            \\"\\"\\", values: nil)\\n        }\\n    }\\n    \\n    func insertUser(name: String, email: String) {\\n        dbQueue.inDatabase { db in\\n            try? db.executeUpdate(\\"INSERT INTO Users (name, email) VALUES (?, ?)\\",\\n                                values: [name, email])\\n        }\\n    }\\n    \\n    func getUsers() -> [[String: Any]] {\\n        var results: [[String: Any]] = []\\n        dbQueue.inDatabase { db in\\n            if let resultSet = try? db.executeQuery(\\"SELECT * FROM Users\\", values: nil) {\\n                while resultSet.next() {\\n                    let user = [\\n                        \\"id\\": resultSet.int(forColumn: \\"id\\"),\\n                        \\"name\\": resultSet.string(forColumn: \\"name\\") ?? \\"\\",\\n                        \\"email\\": resultSet.string(forColumn: \\"email\\") ?? \\"\\"\\n                    ]\\n                    results.append(user)\\n                }\\n            }\\n        }\\n        return results\\n    }\\n}\\n```"},{"title":"Keychain","content":"For secure storage of sensitive data:\\n\\n```swift\\nimport Security\\n\\nclass KeychainManager {\\n    static let shared = KeychainManager()\\n    \\n    func save(key: String, data: Data) -> OSStatus {\\n        let query = [\\n            kSecClass as String: kSecClassGenericPassword as String,\\n            kSecAttrAccount as String: key,\\n            kSecValueData as String: data\\n        ] as [String: Any]\\n        \\n        SecItemDelete(query as CFDictionary)\\n        return SecItemAdd(query as CFDictionary, nil)\\n    }\\n    \\n    func load(key: String) -> Data? {\\n        let query = [\\n            kSecClass as String: kSecClassGenericPassword,\\n            kSecAttrAccount as String: key,\\n            kSecReturnData as String: kCFBooleanTrue!,\\n            kSecMatchLimit as String: kSecMatchLimitOne\\n        ] as [String: Any]\\n        \\n        var dataTypeRef: AnyObject?\\n        let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)\\n        \\n        if status == noErr {\\n            return dataTypeRef as? Data\\n        }\\n        return nil\\n    }\\n    \\n    func delete(key: String) -> OSStatus {\\n        let query = [\\n            kSecClass as String: kSecClassGenericPassword,\\n            kSecAttrAccount as String: key\\n        ] as [String: Any]\\n        \\n        return SecItemDelete(query as CFDictionary)\\n    }\\n}\\n\\n// Usage\\nlet password = \\"secret123\\".data(using: .utf8)!\\nKeychainManager.shared.save(key: \\"userPassword\\", data: password)\\n\\nif let savedPassword = KeychainManager.shared.load(key: \\"userPassword\\") {\\n    print(String(data: savedPassword, encoding: .utf8)!)\\n}\\n```"},{"title":"Best Practices","content":"Follow these best practices for data persistence:\\n\\n1. Choose the right storage method for your data type and size\\n2. Implement proper error handling\\n3. Consider data migration strategies\\n4. Secure sensitive data appropriately\\n5. Implement proper backup and restore mechanisms\\n6. Consider performance implications\\n\\nExample of data migration in Core Data:\\n\\n```swift\\nclass CoreDataStack {\\n    // ... existing code ...\\n    \\n    func migrateStore() {\\n        let description = NSPersistentStoreDescription(url: persistentContainer.persistentStoreDescriptions.first!.url!)\\n        description.shouldMigrateStoreAutomatically = true\\n        description.shouldInferMappingModelAutomatically = true\\n        \\n        persistentContainer.persistentStoreDescriptions = [description]\\n    }\\n}\\n```"},{"title":"Common Use Cases","content":"Here are some common data persistence scenarios:\\n\\n1. Caching API Responses\\n```swift\\nclass CacheManager {\\n    static let shared = CacheManager()\\n    private let cache = NSCache<NSString, NSData>()\\n    \\n    func cacheData(_ data: Data, forKey key: String) {\\n        cache.setObject(data as NSData, forKey: key as NSString)\\n    }\\n    \\n    func getCachedData(forKey key: String) -> Data? {\\n        return cache.object(forKey: key as NSString) as Data?\\n    }\\n}\\n```\\n\\n2. Offline Data Storage\\n```swift\\nclass OfflineManager {\\n    static let shared = OfflineManager()\\n    \\n    func saveOfflineData(_ data: [String: Any], forKey key: String) {\\n        let fileURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\\n            .appendingPathComponent(\\"\\\\(key).json\\")\\n        \\n        if let jsonData = try? JSONSerialization.data(withJSONObject: data) {\\n            try? jsonData.write(to: fileURL)\\n        }\\n    }\\n    \\n    func loadOfflineData(forKey key: String) -> [String: Any]? {\\n        let fileURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\\n            .appendingPathComponent(\\"\\\\(key).json\\")\\n        \\n        if let data = try? Data(contentsOf: fileURL),\\n           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {\\n            return json\\n        }\\n        return nil\\n    }\\n}\\n```\\n\\n3. Settings Management\\n```swift\\nclass SettingsManager {\\n    static let shared = SettingsManager()\\n    private let defaults = UserDefaults.standard\\n    \\n    var theme: String {\\n        get { return defaults.string(forKey: \\"theme\\") ?? \\"light\\" }\\n        set { defaults.set(newValue, forKey: \\"theme\\") }\\n    }\\n    \\n    var notificationsEnabled: Bool {\\n        get { return defaults.bool(forKey: \\"notificationsEnabled\\") }\\n        set { defaults.set(newValue, forKey: \\"notificationsEnabled\\") }\\n    }\\n    \\n    func resetSettings() {\\n        let domain = Bundle.main.bundleIdentifier!\\n        defaults.removePersistentDomain(forName: domain)\\n    }\\n}\\n```"}]}')}}]);